# Maintainability ‚Ä¢ Modularity ‚Ä¢ Simplicity ‚Ä¢ Observability
*General principles for the Cursor agent*
---
## Guiding principles
### Maintainability
- Write code that someone new to the project can understand without explanation.
- Choose clear, intention-revealing names and a consistent style.
- Keep behaviour predictable; avoid hidden side-effects or "magic".
### Modularity
- Break functionality into small, cohesive units that do one thing well.
- Expose the smallest public surface; hide internal details.
- Prefer composition over tight coupling so parts can change independently.
### Simplicity
- Start with the simplest approach that solves the problem; add complexity only when it becomes necessary.
- Remove duplication and dead code; favour explicit, straight-line logic over clever shortcuts.
- Resist premature optimisation‚Äîmake it work, then make it fast *only if needed*.
### Observability
- Build in visibility from the start; code should reveal its runtime behavior and health.
- Use structured logging with consistent levels and meaningful context.
- Expose key metrics and make failures easy to diagnose with clear error messages.
- Design for debuggability‚Äîinclude relevant state in logs and make data flow traceable.
---
## Policy Established
üö´ **NO MORE DEMO, TEST, MOCK, OR TOY SCRIPTS**
- These files clutter the repository
- They provide false/misleading information
- They distract from the real implementation
- All functionality must be in the main pipeline

üîç **GATHER CONTEXT BEFORE CODING**
- Use context7, web search tools, or ask for clarification if you lack sufficient information
- Do not make assumptions about requirements, APIs, or implementation details
- Better to ask than to produce code based on incomplete understanding

---
## Expectations for generated code
1. **Plain-language plan first** ‚Äì briefly outline *what* you'll change and *why*.
2. **Complete output** ‚Äì show full files or diffs; avoid "‚Ä¶" truncation.
3. **Self-contained units** ‚Äì functions, classes, or modules should have one clear responsibility.
4. **Intent-centric comments** ‚Äì document the "why", not obvious "how" details; every public symbol gets a short docstring.
5. **Diagnostic-friendly design** ‚Äì include appropriate logging, error context, and health checks; make it easy to understand what the code is doing at runtime.
6. **Explain compliance** ‚Äì end with a short note on how the result upholds maintainability, modularity, simplicity, and observability.
---
## Why it matters
Following these principles keeps the codebase:
- **Easy to reason about** ‚Äì new contributors ramp up quickly.
- **Safe to evolve** ‚Äì well-defined boundaries limit the blast radius of change.
- **Quick to review** ‚Äì concise diffs and clear rationales speed up feedback cycles.
- **Transparent in operation** ‚Äì runtime behavior is visible and problems are easy to diagnose.

*Keep it simple, keep it small, keep it clear, keep it visible‚Äîand future you (and your teammates) will thank you.* 